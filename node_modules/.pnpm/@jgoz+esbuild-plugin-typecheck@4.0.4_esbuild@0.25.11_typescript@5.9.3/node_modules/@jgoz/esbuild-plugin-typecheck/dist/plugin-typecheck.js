"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "../../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js"(exports2, module2) {
    var p = process || {};
    var argv = p.argv || [];
    var env = p.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  TypecheckRunner: () => TypecheckRunner,
  typecheckPlugin: () => typecheckPlugin
});
module.exports = __toCommonJS(src_exports);

// src/typecheck-runner.ts
var import_path = __toESM(require("path"));
var import_picocolors = __toESM(require_picocolors());
var import_worker_threads = require("worker_threads");
var SUCCESS = process.platform === "win32" ? "\u221A" : "\u2714";
var WARNING = process.platform === "win32" ? "\u203C" : "\u26A0";
var ERROR = process.platform === "win32" ? "\xD7" : "\u2716";
var INFO = process.platform === "win32" ? "i" : "\u2139";
var DEFAULT_LOGGER = {
  info(message) {
    console.info(import_picocolors.default.bold(INFO) + "  " + message);
  },
  warn(message) {
    console.warn(import_picocolors.default.bold(import_picocolors.default.yellow(WARNING)) + "  " + message);
  },
  error(message) {
    console.error(import_picocolors.default.bold(import_picocolors.default.red(ERROR)) + "  " + message);
  },
  success(message) {
    console.info(import_picocolors.default.bold(SUCCESS) + "  " + import_picocolors.default.green(message));
  }
};
var BUILD_MSG = { type: "build" };
var notify = () => {
};
try {
  notify = require("@jgoz/esbuild-plugin-livereload").notify;
} catch {
}
var TypecheckRunner = class {
  constructor({
    absWorkingDir: basedir,
    logger = DEFAULT_LOGGER,
    omitStartLog,
    watch,
    ...options
  }) {
    const inputConfigFile = options.configFile;
    const configFile = inputConfigFile ? import_path.default.isAbsolute(inputConfigFile) ? inputConfigFile : import_path.default.resolve(basedir, inputConfigFile) : void 0;
    const workerData = {
      ...options,
      basedir,
      configFile,
      watch: !!watch
    };
    this.configPath = configFile ?? basedir;
    this.logger = logger;
    this.worker = new import_worker_threads.Worker(import_path.default.resolve(__dirname, "./typescript-worker.js"), { workerData });
    let errors = [];
    let warnings = [];
    let isBuilding;
    let isWatching;
    this.worker.on("message", (msg) => {
      switch (msg.type) {
        case "start": {
          errors = [];
          warnings = [];
          isBuilding ??= msg.build;
          isWatching ??= msg.watch;
          if (!omitStartLog) logStarted(logger, { build: isBuilding, watch: isWatching });
          break;
        }
        case "summary":
        case "diagnostic": {
          errors.push(...msg.diagnostics.filter((d) => d.type === "error").map((d) => d.message));
          warnings.push(...msg.diagnostics.filter((d) => d.type === "warning").map((d) => d.message));
          const err = import_picocolors.default.isColorSupported ? msg.output.pretty : msg.output.standard;
          if (err) console.error(err);
          break;
        }
        case "done": {
          notify("typecheck-plugin", { added: [], removed: [], updated: [], errors, warnings });
          if (msg.errorCount) {
            logFailed(
              logger,
              msg.errorCount === 1 ? "1 error" : `${msg.errorCount} errors`,
              msg.duration
            );
            process.exitCode = 1;
          } else {
            logPassed(logger, msg.duration);
            process.exitCode = 0;
          }
          break;
        }
        case "build":
          throw new Error("Unexpected message from worker: " + JSON.stringify(msg));
      }
    });
    this.worker.on("error", (e) => {
      console.error(e);
      process.exitCode = 1;
    });
    this.worker.on("exit", (code) => {
      if (code !== 0) process.exitCode = code;
    });
  }
  start() {
    this.worker.postMessage(BUILD_MSG);
  }
};
function logStarted(logger, { build = false, watch = false } = {}) {
  const opts = [build && "build", watch && "watch"].filter(Boolean).join(", ");
  const optStr = opts ? import_picocolors.default.cyan(` (${opts})`) : "";
  logger.info("Typecheck started\u2026" + optStr);
}
function logPassed(logger, duration) {
  logger.success("Typecheck passed");
  logger.info(import_picocolors.default.gray(`Typecheck finished in ${duration.toFixed(0)}ms`));
}
function logFailed(logger, numErrors, duration) {
  logger.error(`Typecheck failed with ${import_picocolors.default.bold(numErrors)}`);
  logger.info(import_picocolors.default.gray(`Typecheck finished in ${duration.toFixed(0)}ms`));
}

// src/typecheck-plugin.ts
function typecheckPlugin({
  configFile,
  watch,
  ...options
} = {}) {
  return {
    name: "typecheck-plugin",
    setup(build) {
      const { absWorkingDir = process.cwd(), tsconfig } = build.initialOptions;
      const runner = new TypecheckRunner({
        ...options,
        absWorkingDir,
        configFile: configFile ?? tsconfig,
        watch
      });
      build.onStart(() => {
        runner.start();
      });
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TypecheckRunner,
  typecheckPlugin
});
//# sourceMappingURL=plugin-typecheck.js.map
