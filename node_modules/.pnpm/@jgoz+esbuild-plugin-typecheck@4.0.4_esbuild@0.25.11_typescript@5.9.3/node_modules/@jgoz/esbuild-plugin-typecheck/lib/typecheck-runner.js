"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypecheckRunner = void 0;
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const worker_threads_1 = require("worker_threads");
const SUCCESS = process.platform === 'win32' ? '√' : '✔';
const WARNING = process.platform === 'win32' ? '‼' : '⚠';
const ERROR = process.platform === 'win32' ? '×' : '✖';
const INFO = process.platform === 'win32' ? 'i' : 'ℹ';
const DEFAULT_LOGGER = {
    info(message) {
        console.info(picocolors_1.default.bold(INFO) + '  ' + message);
    },
    warn(message) {
        console.warn(picocolors_1.default.bold(picocolors_1.default.yellow(WARNING)) + '  ' + message);
    },
    error(message) {
        console.error(picocolors_1.default.bold(picocolors_1.default.red(ERROR)) + '  ' + message);
    },
    success(message) {
        console.info(picocolors_1.default.bold(SUCCESS) + '  ' + picocolors_1.default.green(message));
    },
};
const BUILD_MSG = { type: 'build' };
let notify = () => { };
try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    notify = require('@jgoz/esbuild-plugin-livereload').notify;
}
catch { }
class TypecheckRunner {
    constructor({ absWorkingDir: basedir, logger = DEFAULT_LOGGER, omitStartLog, watch, ...options }) {
        const inputConfigFile = options.configFile;
        const configFile = inputConfigFile
            ? path_1.default.isAbsolute(inputConfigFile)
                ? inputConfigFile
                : path_1.default.resolve(basedir, inputConfigFile)
            : undefined;
        const workerData = {
            ...options,
            basedir,
            configFile,
            watch: !!watch,
        };
        this.configPath = configFile ?? basedir;
        this.logger = logger;
        this.worker = new worker_threads_1.Worker(path_1.default.resolve(__dirname, './typescript-worker.js'), { workerData });
        let errors = [];
        let warnings = [];
        let isBuilding;
        let isWatching;
        this.worker.on('message', (msg) => {
            switch (msg.type) {
                case 'start': {
                    errors = [];
                    warnings = [];
                    isBuilding ??= msg.build;
                    isWatching ??= msg.watch;
                    if (!omitStartLog)
                        logStarted(logger, { build: isBuilding, watch: isWatching });
                    break;
                }
                case 'summary':
                case 'diagnostic': {
                    errors.push(...msg.diagnostics.filter(d => d.type === 'error').map(d => d.message));
                    warnings.push(...msg.diagnostics.filter(d => d.type === 'warning').map(d => d.message));
                    const err = picocolors_1.default.isColorSupported ? msg.output.pretty : msg.output.standard;
                    if (err)
                        console.error(err);
                    break;
                }
                case 'done': {
                    notify('typecheck-plugin', { added: [], removed: [], updated: [], errors, warnings });
                    if (msg.errorCount) {
                        logFailed(logger, msg.errorCount === 1 ? '1 error' : `${msg.errorCount} errors`, msg.duration);
                        process.exitCode = 1;
                    }
                    else {
                        logPassed(logger, msg.duration);
                        process.exitCode = 0;
                    }
                    break;
                }
                case 'build':
                    throw new Error('Unexpected message from worker: ' + JSON.stringify(msg));
            }
        });
        this.worker.on('error', e => {
            console.error(e);
            process.exitCode = 1;
        });
        this.worker.on('exit', code => {
            if (code !== 0)
                process.exitCode = code;
        });
    }
    start() {
        this.worker.postMessage(BUILD_MSG);
    }
}
exports.TypecheckRunner = TypecheckRunner;
function logStarted(logger, { build = false, watch = false } = {}) {
    const opts = [build && 'build', watch && 'watch'].filter(Boolean).join(', ');
    const optStr = opts ? picocolors_1.default.cyan(` (${opts})`) : '';
    logger.info('Typecheck started…' + optStr);
}
function logPassed(logger, duration) {
    logger.success('Typecheck passed');
    logger.info(picocolors_1.default.gray(`Typecheck finished in ${duration.toFixed(0)}ms`));
}
function logFailed(logger, numErrors, duration) {
    logger.error(`Typecheck failed with ${picocolors_1.default.bold(numErrors)}`);
    logger.info(picocolors_1.default.gray(`Typecheck finished in ${duration.toFixed(0)}ms`));
}
//# sourceMappingURL=typecheck-runner.js.map