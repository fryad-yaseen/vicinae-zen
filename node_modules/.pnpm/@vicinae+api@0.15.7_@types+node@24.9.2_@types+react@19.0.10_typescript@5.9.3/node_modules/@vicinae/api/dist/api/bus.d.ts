import { MessagePort } from "worker_threads";
import * as ipc from "./proto/ipc";
import * as extension from "./proto/extension";
import { Result } from "./lib/result";
export type Message<T = Record<string, any>> = {
    envelope: {
        id: string;
        type: "request" | "response" | "event";
        action: string;
    };
    error: {
        message?: string;
    } | null;
    data: T;
};
declare namespace EventListener {
    type ArgValue = string | number | Record<any, any> | boolean | null | undefined;
    type Callback = (...args: EventListener.ArgValue[]) => void;
}
type EventListenerInfo = {
    callback: EventListener.Callback;
};
type Requests = {
    [K in keyof Required<extension.RequestData>]: {
        [R in keyof Required<Required<extension.RequestData>[K]>]: {
            data: NonNullable<Required<extension.RequestData>[K][R]>;
        };
    };
};
type Responses = {
    [K in keyof Required<extension.ResponseData>]: {
        [R in keyof Required<Required<extension.ResponseData>[K]>]: {
            data: NonNullable<Required<extension.ResponseData>[K][R]>;
        };
    };
};
type EndpointMapping = {
    "app.list": "app.list";
    "app.open": "app.open";
    "app.getDefault": "app.getDefault";
    "ui.render": "ui.render";
    "ui.showToast": "ui.showToast";
    "ui.hideToast": "ui.hideToast";
    "ui.updateToast": "ui.updateToast";
    "ui.pushView": "ui.pushView";
    "ui.popView": "ui.popView";
    "ui.closeMainWindow": "ui.closeMainWindow";
    "ui.showHud": "ui.showHud";
    "ui.setSearchText": "ui.setSearchText";
    "ui.confirmAlert": "ui.confirmAlert";
    "ui.getSelectedText": "ui.getSelectedText";
    "wm.ping": "wm.ping";
    "wm.getActiveWindow": "wm.getActiveWindow";
    "wm.getActiveWorkspace": "wm.getActiveWorkspace";
    "wm.getWindows": "wm.getWindows";
    "wm.getWorkspaces": "wm.getWorkspaces";
    "wm.setWindowBounds": "wm.setWindowBounds";
    "fileSearch.search": "fileSearch.search";
    "ui.popToRoot": "ui.popToRoot";
    "storage.get": "storage.get";
    "storage.set": "storage.set";
    "storage.remove": "storage.remove";
    "storage.clear": "storage.clear";
    "storage.list": "storage.list";
    "oauth.authorize": "oauth.authorize";
    "clipboard.copy": "clipboard.copy";
    "clipboard.paste": "clipboard.paste";
    "clipboard.readContent": "clipboard.readContent";
    "clipboard.clear": "clipboard.clear";
};
type RequestEndpoint = keyof EndpointMapping;
type ResponseEndpoint = EndpointMapping[RequestEndpoint];
type ExtractRequestType<T extends RequestEndpoint> = T extends `${infer Category}.${infer Action}` ? Category extends keyof Requests ? Action extends keyof Requests[Category] ? Requests[Category][Action] : never : never : never;
type ExtractResponseType<T extends ResponseEndpoint> = T extends `${infer Category}.${infer Action}` ? Category extends keyof Responses ? Action extends keyof Responses[Category] ? Responses[Category][Action] : never : never : never;
type Map = {
    [K in RequestEndpoint]: {
        request: ExtractRequestType<K>["data"];
        response: ExtractResponseType<EndpointMapping[K]>["data"];
    };
};
declare class Bus {
    private readonly port;
    private requestMap;
    private safeRequestMap;
    private eventListeners;
    turboRequest<T extends RequestEndpoint>(endpoint: T, data: Map[T]["request"]): Promise<Result<Map[T]["response"], Error>>;
    private handleSafeMessage;
    emitCrash(errorText: string): void;
    constructor(port: MessagePort);
    listEventListeners(type: string): EventListenerInfo[];
    subscribe(type: string, cb: EventListenerInfo["callback"]): {
        unsubscribe: () => void;
    };
    emit(action: string, data: Record<string, any>): void;
    sendMessage(message: ipc.ExtensionMessage): void;
    addEventHandler(cb: EventListenerInfo['callback']): {
        id: string;
        unsubscribe: () => void;
    };
    replaceEventHandler(id: string, handler: EventListenerInfo['callback']): void;
    removeEventHandler(id: string): void;
    private request2;
}
/**
 * IPC bus to communicate with the extension manager.
 * If you are using this from inside your extension, you are WRONG and you should stop.
 */
export declare const bus: Bus;
export {};
