"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.bus = void 0;
const crypto_1 = require("crypto");
const worker_threads_1 = require("worker_threads");
const ipc = __importStar(require("./proto/ipc"));
const extension = __importStar(require("./proto/extension"));
const result_1 = require("./lib/result");
class Bus {
    port;
    requestMap = new Map();
    safeRequestMap = new Map();
    eventListeners = new Map();
    async turboRequest(endpoint, data) {
        const [category, requestId] = endpoint.split(".");
        const request = extension.RequestData.create({
            [category]: { [requestId]: data },
        });
        const res = await this.request2(request);
        if (!res.ok) {
            return (0, result_1.Err)(res.error);
        }
        const resData = res.value[category]?.[requestId];
        if (!resData)
            return (0, result_1.Err)(Error(`Invalid response for request of type ${endpoint}: ${JSON.stringify(res, null, 2)}`));
        //console.error(`Got valid response for ${endpoint}`);
        return (0, result_1.Ok)(resData);
    }
    handleSafeMessage(message) {
        if (message.response) {
            //console.log('got response response', message.response.requestId);
            const request = this.safeRequestMap.get(message.response.requestId);
            if (!request) {
                //console.error(`Received response for unknown request ${message.response.requestId}`);
                return;
            }
            this.requestMap.delete(message.response.requestId);
            request.resolve(message.response);
            return;
        }
        if (message.event) {
            const { id, generic } = message.event;
            //console.error('got event with id', id);
            if (generic) {
                const listeners = this.listEventListeners(id);
                const args = JSON.parse(generic.json);
                for (const listener of listeners) {
                    listener.callback(...(args ?? []));
                }
            }
        }
    }
    emitCrash(errorText) {
        this.sendMessage({
            event: {
                id: (0, crypto_1.randomUUID)(),
                crash: { text: errorText },
            },
        });
    }
    constructor(port) {
        this.port = port;
        if (!port)
            return;
        port.on("message", (buf) => {
            this.handleSafeMessage(ipc.ExtensionMessage.decode(buf));
        });
        port.on("messageerror", (error) => {
            console.error(`Message error from manager`, error);
        });
        port.on("close", () => {
            console.error(`Parent port closed prematurely`);
        });
    }
    listEventListeners(type) {
        return this.eventListeners.get(type) ?? [];
    }
    subscribe(type, cb) {
        const item = { callback: cb };
        let listeners = this.eventListeners.get(type);
        if (!listeners) {
            this.eventListeners.set(type, [item]);
        }
        else {
            listeners.push(item);
        }
        return {
            unsubscribe: () => {
                const listeners = this.eventListeners.get(type) ?? [];
                const index = listeners.indexOf(item);
                if (index != -1) {
                    listeners.splice(index, 1);
                    if (listeners.length === 0) {
                        this.eventListeners.delete(type);
                    }
                }
            },
        };
    }
    emit(action, data) {
        const message = ipc.ExtensionMessage.create({
            event: {
                id: action,
                generic: { json: JSON.stringify([data]) },
            },
        });
        this.sendMessage(message);
    }
    sendMessage(message) {
        this.port.postMessage(ipc.ExtensionMessage.encode(message).finish());
    }
    addEventHandler(cb) {
        const id = `handler-${(0, crypto_1.randomUUID)()}`;
        const { unsubscribe } = this.subscribe(id, cb);
        return { id, unsubscribe };
    }
    replaceEventHandler(id, handler) {
        for (const listener of this.eventListeners.get(id) ?? []) {
            listener.callback = handler;
        }
    }
    removeEventHandler(id) {
        this.eventListeners.delete(id);
    }
    request2(data, options = {}) {
        const req = extension.Request.create({ requestId: (0, crypto_1.randomUUID)(), data });
        return new Promise((resolve, reject) => {
            let timeout;
            if (options.timeout) {
                timeout = setTimeout(() => resolve((0, result_1.Err)(Error(`request timed out`))), options.timeout);
            }
            const resolver = (response) => {
                clearTimeout(timeout);
                if (response.error) {
                    return resolve((0, result_1.Err)(new Error(response.error.errorText)));
                }
                if (!response.data) {
                    return resolve((0, result_1.Err)(new Error("No error and no data")));
                }
                resolve((0, result_1.Ok)(response.data));
            };
            try {
                this.safeRequestMap.set(req.requestId, { resolve: resolver });
                this.sendMessage({ request: req });
            }
            catch (error) {
                reject(error);
            }
        });
    }
}
/**
 * IPC bus to communicate with the extension manager.
 * If you are using this from inside your extension, you are WRONG and you should stop.
 */
exports.bus = new Bus(worker_threads_1.parentPort);
