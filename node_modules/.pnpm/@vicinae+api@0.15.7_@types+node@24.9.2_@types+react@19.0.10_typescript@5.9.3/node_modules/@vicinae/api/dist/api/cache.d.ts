export declare namespace Cache {
    /**
     * The options for creating a new {@link Cache}.
     */
    interface Options {
        /**
         * If set, the Cache will be namespaced via a subdirectory.
         * This can be useful to separate the caches for individual commands of an extension.
         * By default, the cache is shared between the commands of an extension.
         */
        namespace?: string;
        /**
         * The capacity in bytes. If the stored data exceeds the capacity, the least recently used data is removed.
         * The default capacity is 10 MB.
         */
        capacity?: number;
    }
    type Subscriber = (key: string | undefined, data: string | undefined) => void;
    type Subscription = () => void;
}
/**
 * Caching abstraction that stores data on disk and supports LRU (least recently used) access.
 * Values can only be stored as plain text strings, so it is up to you to serialize your data in an appropriate way.
 * For instance, you could store json using `JSON.stringify` and `JSON.parse` it back.
 * If you need to store binary data, you could encode it in base64.
 *
 * Unlike the local storage API, this API exclusively uses the extension's support directory to store its data.
 * No calls to internal Vicinae APIs are required, hence why all methods in this class are synchronous.
 * Another major difference is that cache data is not encrypted, so it's not suitable to store secrets.
 * (local storage currently isn't either, but that will change in the future)
 */
export declare class Cache {
    constructor(options?: Cache.Options);
    /**
     * @returns the full path to the directory where the data is stored on disk.
     * @remarks This is provided for informative purpose only. You should not attempt to mutate anything
     * in this directory by yourself. Also note that the way cache data is serialized on disk can (will) change
     * across versions.
     */
    get storageDirectory(): string;
    /**
     * @returns the data for the given key, or `undefined` if there is no data.
     * @remarks To solely check for existence of a key, use {@link has}.
     */
    get: (key: string) => string | undefined;
    /**
     * @returns `true` if data for the key exists, `false` otherwise.
     * @remarks You can use this method to check for entries without affecting the LRU access.
     */
    has: (key: string) => boolean;
    /**
     * @returns whether the cache is empty.
     */
    get isEmpty(): boolean;
    /**
     * Sets the data for the given key.
     * If the data exceeds the configured `capacity`, the least recently used entries are removed.
     * This also notifies registered subscribers (see {@link subscribe}).
     * @remarks An individual cache entry cannot be bigger than the configured capacity. If this happens, an error will be thrown.
     */
    set: (key: string, data: string) => void;
    /**
     * Removes the data for the given key.
     * This also notifies registered subscribers (see {@link subscribe}).
     * @returns `true` if data for the key was removed, `false` otherwise.
     */
    remove: (key: string) => boolean;
    /**
     * Clears all stored data.
     * This also notifies registered subscribers (see {@link subscribe}) unless the  `notifySubscribers` option is set to `false`.
     */
    clear: (options?: {
        notifySubscribers: boolean;
    }) => void;
    /**
     * Registers a new subscriber that gets notified when cache data is set or removed.
     * @returns a function that can be called to remove the subscriber.
     */
    subscribe: (subscriber: Cache.Subscriber) => Cache.Subscription;
    private keyDataPath;
    private readKeyData;
    private writeKeyData;
    private keyHash;
    private get dataDir();
    private dataPath;
    private get indexPath();
    private updateLRU;
    private popLRU;
    private removeImpl;
    private initIndex;
    private loadIndex;
    private removeCacheDirectory;
    private syncIndex;
    private emptyIndex;
    /**
     * We store this inside the cache index file in order to know
     * when a breaking change occurs.
     * If we want to change the way the data is stored we just change this,
     * which will force a full cache clear and use the new format.
     */
    private revision;
    private capacity;
    private subscribers;
    private storageDir;
    private index;
    private static DEFAULT_CACHE_SIZE;
    private static CACHE_DIR_NAME;
}
