"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
const node_path_1 = __importDefault(require("node:path"));
const node_fs_1 = require("node:fs");
const node_crypto_1 = require("node:crypto");
const environment_1 = require("./environment");
/**
 * Caching abstraction that stores data on disk and supports LRU (least recently used) access.
 * Values can only be stored as plain text strings, so it is up to you to serialize your data in an appropriate way.
 * For instance, you could store json using `JSON.stringify` and `JSON.parse` it back.
 * If you need to store binary data, you could encode it in base64.
 *
 * Unlike the local storage API, this API exclusively uses the extension's support directory to store its data.
 * No calls to internal Vicinae APIs are required, hence why all methods in this class are synchronous.
 * Another major difference is that cache data is not encrypted, so it's not suitable to store secrets.
 * (local storage currently isn't either, but that will change in the future)
 */
class Cache {
    constructor(options) {
        this.storageDir = node_path_1.default.join(environment_1.environment.supportPath, Cache.CACHE_DIR_NAME);
        this.capacity = options?.capacity ?? Cache.DEFAULT_CACHE_SIZE;
        if (options?.namespace) {
            this.storageDir = node_path_1.default.join(this.storageDir, options.namespace);
        }
        (0, node_fs_1.mkdirSync)(this.dataDir, { recursive: true });
        this.index = this.loadIndex() ?? this.emptyIndex();
        if (this.index.revision !== this.revision) {
            this.clear();
        }
    }
    /**
     * @returns the full path to the directory where the data is stored on disk.
     * @remarks This is provided for informative purpose only. You should not attempt to mutate anything
     * in this directory by yourself. Also note that the way cache data is serialized on disk can (will) change
     * across versions.
     */
    get storageDirectory() {
        return this.storageDir;
    }
    /**
     * @returns the data for the given key, or `undefined` if there is no data.
     * @remarks To solely check for existence of a key, use {@link has}.
     */
    get = (key) => {
        const info = this.index.keys[key];
        if (!info)
            return undefined;
        this.updateLRU(key);
        this.syncIndex();
        return this.readKeyData(key);
    };
    /**
     * @returns `true` if data for the key exists, `false` otherwise.
     * @remarks You can use this method to check for entries without affecting the LRU access.
     */
    has = (key) => {
        return typeof this.index.keys[key] !== 'undefined';
    };
    /**
     * @returns whether the cache is empty.
     */
    get isEmpty() {
        return Object.keys(this.index.keys).length === 0;
    }
    /**
     * Sets the data for the given key.
     * If the data exceeds the configured `capacity`, the least recently used entries are removed.
     * This also notifies registered subscribers (see {@link subscribe}).
     * @remarks An individual cache entry cannot be bigger than the configured capacity. If this happens, an error will be thrown.
     */
    set = (key, data) => {
        if (data.length > this.capacity) {
            throw new Error(`A single cache entry cannot be bigger than the total capacity of the cache. The data for key ${key} is ${data.length} bytes long while the capacity is set to ${this.capacity}. You should either reduce the amount of data stored or increase the cache's capacity.`);
        }
        const info = this.index.keys[key];
        let newTotalSize = this.index.size + data.length - (info?.size ?? 0);
        if (newTotalSize > this.capacity) {
            this.popLRU();
            return this.set(key, data); // FIXME: get rid of recursion 
        }
        this.index.size = newTotalSize;
        this.index.keys[key] = { size: data.length };
        this.updateLRU(key);
        for (const sub of this.subscribers) {
            sub(key, data);
        }
        this.writeKeyData(key, data);
        this.syncIndex();
    };
    /**
     * Removes the data for the given key.
     * This also notifies registered subscribers (see {@link subscribe}).
     * @returns `true` if data for the key was removed, `false` otherwise.
     */
    remove = (key) => {
        const removed = this.removeImpl(key);
        this.syncIndex();
        return removed;
    };
    /**
     * Clears all stored data.
     * This also notifies registered subscribers (see {@link subscribe}) unless the  `notifySubscribers` option is set to `false`.
     */
    clear = (options) => {
        const notify = options?.notifySubscribers ?? true;
        this.removeCacheDirectory();
        this.initIndex();
        if (!notify)
            return;
        for (const key of Object.keys(this.index.keys)) {
            for (const subscriber of this.subscribers) {
                subscriber(key, undefined);
            }
        }
    };
    /**
     * Registers a new subscriber that gets notified when cache data is set or removed.
     * @returns a function that can be called to remove the subscriber.
     */
    subscribe = (subscriber) => {
        this.subscribers.push(subscriber);
        return () => {
            this.subscribers.splice(this.subscribers.indexOf(subscriber), 1);
        };
    };
    keyDataPath(key) {
        return this.dataPath(this.keyHash(key));
    }
    readKeyData(key) {
        return (0, node_fs_1.readFileSync)(this.keyDataPath(key), 'utf8');
    }
    writeKeyData(key, data) {
        (0, node_fs_1.writeFileSync)(this.keyDataPath(key), data);
    }
    keyHash(key) {
        return (0, node_crypto_1.hash)('md5', key);
    }
    get dataDir() {
        return node_path_1.default.join(this.storageDir, 'data');
    }
    dataPath(id) {
        return node_path_1.default.join(this.dataDir, id);
    }
    get indexPath() {
        return node_path_1.default.join(this.storageDir, 'index.json');
    }
    updateLRU(key) {
        const idx = this.index.lru.findIndex((entry) => key == entry.key);
        if (idx !== -1)
            this.index.lru.splice(idx, 1);
        this.index.lru.unshift({ key, lastUsedAt: Date.now() });
    }
    popLRU() {
        if (this.index.lru.length === 0)
            return;
        this.removeImpl(this.index.lru.pop().key);
    }
    removeImpl(key) {
        const info = this.index.keys[key];
        if (!info)
            return false;
        (0, node_fs_1.rmSync)(this.keyDataPath(key), { force: true });
        this.index.size -= info.size;
        delete this.index.keys[key];
        for (const sub of this.subscribers) {
            sub(key, undefined);
        }
        return true;
    }
    initIndex() {
        const index = { revision: this.revision, keys: {}, size: 0, lru: [] };
        (0, node_fs_1.mkdirSync)(this.dataDir, { recursive: true });
        const indexPath = node_path_1.default.join(this.storageDir, "index.json");
        (0, node_fs_1.writeFileSync)(indexPath, JSON.stringify(index, null, 2));
        return index;
    }
    loadIndex() {
        const indexPath = node_path_1.default.join(this.storageDir, "index.json");
        if (!(0, node_fs_1.existsSync)(indexPath))
            return null;
        return JSON.parse((0, node_fs_1.readFileSync)(indexPath, 'utf8'));
    }
    removeCacheDirectory() {
        (0, node_fs_1.rmSync)(this.dataDir, { recursive: true, force: true });
    }
    syncIndex() {
        (0, node_fs_1.writeFileSync)(this.indexPath, JSON.stringify(this.index, null, 2));
    }
    emptyIndex() {
        return { revision: this.revision, keys: {}, lru: [], size: 0 };
    }
    /**
     * We store this inside the cache index file in order to know
     * when a breaking change occurs.
     * If we want to change the way the data is stored we just change this,
     * which will force a full cache clear and use the new format.
     */
    revision = '1';
    capacity;
    subscribers = [];
    storageDir;
    index;
    static DEFAULT_CACHE_SIZE = 1e7;
    static CACHE_DIR_NAME = ".cache";
}
exports.Cache = Cache;
