"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth = exports.PKCEClient = void 0;
const node_crypto_1 = require("node:crypto");
const image_1 = require("./image");
const bus_1 = require("./bus");
var OauthRedirectMethod;
(function (OauthRedirectMethod) {
    /**
     * Use this type for a redirect back to the Raycast website, which will then open the extension.
     * In the OAuth app, configure `https://raycast.com/redirect?packageName=Extension`
     * (This is a static redirect URL for all extensions.)
     * If the provider does not accept query parameters in redirect URLs, you can alternatively use `https://raycast.com/redirect/extension`
     * and then customize the {@link OAuth.AuthorizationRequest} via its `extraParameters` property. For example add:
     *  `extraParameters: { "redirect_uri": "https://raycast.com/redirect/extension" }`
     */
    OauthRedirectMethod["Web"] = "web";
    /**
     * Use this type for an app-scheme based redirect that directly opens Raycast.
     * In the OAuth app, configure `raycast://oauth?package_name=Extension`
     */
    OauthRedirectMethod["App"] = "app";
    /**
     * Use this type for a URI-style app scheme that directly opens Raycast.
     * In the OAuth app, configure `com.raycast:/oauth?package_name=Extension`
     * (Note the single slash - Google, for example, would require this flavor for an OAuth app where the Bundle ID is `com.raycast`)
     */
    OauthRedirectMethod["AppURI"] = "appURI";
})(OauthRedirectMethod || (OauthRedirectMethod = {}));
class PKCEClient {
    redirectMethod;
    providerName;
    providerIcon;
    providerId;
    description;
    resolvesOnRedirect;
    isAuthorizing;
    constructor(options) {
        this.providerId = options.providerId;
        this.providerName = options.providerName;
        this.providerIcon = options.providerIcon;
        this.description = options.description;
        this.redirectMethod = options.redirectMethod;
        this.resolvesOnRedirect = false;
        this.isAuthorizing = false;
    }
    buildAuthUrl(options, state, codeChallenge, redirectURI) {
        const params = new URLSearchParams({
            response_type: "code",
            client_id: options.clientId,
            redirect_uri: redirectURI,
            scope: options.scope,
            state: state,
            code_challenge: codeChallenge,
            code_challenge_method: "S256",
            ...options.extraParameters,
        });
        return `${options.endpoint}?${params}`;
    }
    getRedirectURI() {
        switch (this.redirectMethod) {
            case exports.OAuth.RedirectMethod.Web:
                return "https://raycast.com/redirect?packageName=Extension";
            case exports.OAuth.RedirectMethod.App:
                return "raycast://oauth?package_name=Extension";
            case exports.OAuth.RedirectMethod.AppURI:
                return "com.raycast:/oauth?package_name=Extension";
        }
    }
    /**
     * Creates an authorization request for the provided authorization endpoint, client ID, and scopes.
     * You need to first create the authorization request before calling {@link OAuth.PKCEClient.authorize}.
     *
     * @remarks The generated code challenge for the PKCE request uses the S256 method.
     *
     * @returns A promise for an {@link OAuth.AuthorizationRequest} that you can use as input for {@link OAuth.PKCEClient.authorize}.
     */
    async authorizationRequest(options) {
        const codeVerifier = (0, node_crypto_1.randomBytes)(128).toString("hex");
        const codeChallenge = (0, node_crypto_1.createHash)("sha256")
            .update(codeVerifier)
            .digest("base64url");
        const state = (0, node_crypto_1.randomBytes)(32).toString("hex");
        const redirectURI = this.getRedirectURI();
        return {
            state,
            codeChallenge,
            codeVerifier,
            redirectURI,
            toURL: () => this.buildAuthUrl(options, state, codeChallenge, redirectURI),
        };
    }
    /**
     * Starts the authorization and shows the OAuth overlay in Raycast.
     * As parameter you can either directly use the returned request from {@link OAuth.PKCEClient.authorizationRequest},
     * or customize the URL by extracting parameters from {@link OAuth.AuthorizationRequest} and providing your own URL via {@link AuthorizationOptions}.
     * Eventually the URL will be used to open the authorization page of the provider in the web browser.
     *
     * @returns A promise for an {@link OAuth.AuthorizationResponse}, which contains the authorization code needed for the token exchange.
     * The promise is resolved when the user was redirected back from the provider's authorization page to the Raycast extension.
     */
    async authorize(options) {
        const isAuthorizationOptions = (s) => {
            return typeof s.url === "string";
        };
        const res = await bus_1.bus.turboRequest("oauth.authorize", {
            client: {
                id: this.providerId,
                description: this.description ?? "Connect to your account",
                name: this.providerName,
                icon: this.providerIcon
                    ? (0, image_1.serializeProtoImage)(this.providerIcon)
                    : undefined,
            },
            url: isAuthorizationOptions(options) ? options.url : options.toURL(),
        });
        if (!res.ok) {
            throw res.error;
        }
        return { authorizationCode: res.value.code };
    }
    authorizationURL;
    /**
     * Securely stores a {@link OAuth.TokenSet} for the provider. Use this after fetching the access token from the provider.
     * If the provider returns a a standard OAuth JSON token response, you can directly pass the {@link OAuth.TokenResponse}.
     * At a minimum, you need to set the {@link OAuth.TokenSet.accessToken}, and typically you also set {@link OAuth.TokenSet.refreshToken} and {@link OAuth.TokenSet.isExpired}.
     * Raycast automatically shows a logout preference for the extension when a token set was saved.
     *
     * @remarks If you want to make use of the convenience {@link OAuth.TokenSet.isExpired} method, the property {@link OAuth.TokenSet.expiresIn} must be configured.
     *
     * @returns A promise that resolves when the token set has been stored.
     */
    async setTokens(options) { }
    /**
     * Retrieves the stored {@link OAuth.TokenSet} for the client.
     * You can use this to initially check whether the authorization flow should be initiated or
     * the user is already logged in and you might have to refresh the access token.
     *
     * @returns A promise that resolves when the token set has been retrieved.
     */
    async getTokens() {
        return undefined;
    }
    /**
     * Removes the stored {@link OAuth.TokenSet} for the client.
     *
     * @remarks Raycast automatically shows a logout preference that removes the token set.
     * Use this method only if you need to provide an additional logout option in your extension or you want to remove the token set because of a migration.
     *
     */
    async removeTokens() { }
}
exports.PKCEClient = PKCEClient;
class TokenSet {
    accessToken = "";
    refreshToken;
    idToken;
    expiresIn;
    scope;
    updatedAt = new Date();
    isExpired() {
        return true;
    }
}
exports.OAuth = {
    PKCEClient,
    RedirectMethod: OauthRedirectMethod,
    TokenSet,
};
